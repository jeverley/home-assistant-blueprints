blueprint:
  name: Dimmer Power on Minimum
  description: "Automatically set lights to a minimum brightness when turning on, with configurable minimums per light entity"
  domain: automation
  source_url: https://raw.githubusercontent.com/jeverley/home-assistant-blueprints/refs/heads/main/blueprints/automation/lighting_brightness_on_min.yaml
  input:
    light_config:
      name: Lights configuration
      description: "Configure minimum brightness percentage and cooldown duration for each light"
      selector:
        object:
          label_field: entity_id
          multiple: true
          fields:
            entity_id:
              label: Light
              selector:
                entity:
                  multiple: false
                  filter:
                    - domain:
                        - light
            min_pct:
              label: Power on minimum brightness
              selector:
                number:
                  min: 1
                  max: 100
                  unit_of_measurement: "%"
            cooldown:
              label: Cooldown duration
              selector:
                number:
                  min: 0
                  max: 60
                  step: 1
                  unit_of_measurement: s
      default: []
    default_transition:
      name: Default transition
      description: "Default transition time when not specified in the trigger event"
      default: 0
      selector:
        number:
          min: 0
          max: 60
          step: 1
          unit_of_measurement: s

trigger_variables:
  scale_factor: 2.55
  default_transition: !input default_transition
  light_config_objects: !input light_config
  light_config: |
    {% set global = namespace(config={}) %}
    {% for config in light_config_objects %}
      {% set global.config = dict(global.config, **{
        config.entity_id: {
          'on_minimum': (config.min_pct|default(0) * scale_factor) | round,
          'cooldown': config.cooldown|default(0)
        }
      }) %}
    {% endfor %}
    {{ global.config }}

triggers:
  - alias: When call_service event is fired for light turn_on
    id: call_service
    trigger: event
    event_type: call_service
    event_data:
      domain: light
      service: turn_on
  - alias: When call_service event is fired for light toggle
    id: call_service
    trigger: event
    event_type: call_service
    event_data:
      domain: light
      service: toggle
  - trigger: event
    id: state_changed
    event_type: state_changed
    event_data: {}
    enabled: false

variables:
  trigger_time: |
    {% if trigger.event is defined %}
      {{ trigger.event.time_fired }}
    {% elif trigger.new_state is defined %}
      {{ trigger.new_state.last_changed }}
    {% else %}
      {{ now() }}
    {% endif %}
  trigger_entity_ids: |
    {% if trigger.event is defined %}
      {# Resolve entity_ids from event targets #}
      {% set sd = trigger.event.data.service_data %}
      {% set entity_ids = [] if sd.entity_id is not defined else [sd.entity_id] if sd.entity_id is string else sd.entity_id %}
      {% set device_ids = [] if sd.device_ids is not defined else [sd.device_ids] if sd.device_ids is string else sd.device_ids %}
      {% set area_ids = [] if sd.area_ids is not defined else [sd.area_ids] if sd.area_ids is string else sd.area_ids %}
      {% set floor_ids = [] if sd.floor_ids is not defined else [sd.floor_ids] if sd.floor_ids is string else sd.floor_ids %}
      {% set label_ids = [] if sd.label_ids is not defined else [sd.label_ids] if sd.label_ids is string else sd.label_ids %}
      {% set resolved_entities =
        (
          (area_ids | map('area_entities')|flatten if area_ids else [])
          + (floor_ids | map('floor_entities')|flatten if floor_ids else [])
          + (label_ids | map('label_entities')|flatten if label_ids else [])
          + (label_ids | map('label_devices')|flatten | map('device_entities')|flatten if label_ids else [])
        ) | select('contains', 'light.') | list
      %}
      {{ (resolved_entities + entity_ids) | unique | list }}
    {% elif trigger.new_state is defined %}
      {{ [trigger.new_state.entity_id] }}
    {% else %}
      {{ [] }}
    {% endif %}
  matched_entity_ids: |
    {{ trigger_entity_ids | select('in', light_config) | list }}
  matched_off_duration: |
    {# Get the duration in seconds that each matched light was off #}
    {% set global = namespace(off_duration={}) %}
    {% if trigger.old_state is not defined %}
      {% for state in expand(matched_entity_ids) %}
        {% if state.state == 'off' %}
          {% set global.off_duration = dict(global.off_duration, **{
            state.entity_id: (as_datetime(trigger_time) - state.last_changed).total_seconds()
          }) %}
        {% endif %}
      {% endfor %}
    {% elif trigger.old_state.state == 'off' and matched_entity_ids %}
      {% set global.off_duration = {trigger.entity_id: (as_datetime(trigger_time) - trigger.old_state.last_changed).total_seconds()} %}
    {% endif %}
    {{ global.off_duration }}
  target_entity_ids: |
    {{ matched_off_duration.keys() | list }}
  brightness: |
    {% if trigger.new_state is defined %}
      {{ trigger.new_state.attributes.brightness|default(none)|int(none) }}
    {% elif trigger.event is not defined %}
      {{ none }}
    {% elif trigger.event.data.service_data.brightness is defined %}
      {{ trigger.event.data.service_data.brightness|int(none) }}
    {% elif trigger.event.data.service_data.brightness_pct is defined %}
      {{ (trigger.event.data.service_data.brightness_pct|int(none) * scale_factor) | round }}
    {% else %}
      {{ none }}
    {% endif %}
  transition: |
    {{
      trigger.event.data.service_data.transition|default(default_transition)|int(0)
      if trigger.event is defined
      else 0
    }}

conditions:
  - alias: If the trigger has valid target lights that were off
    condition: template
    value_template: "{{ not not target_entity_ids }}"
  - condition: or
    conditions:
      - alias: If transition is long enough to perceive a delay
        condition: template
        value_template: |
          {{ transition > 1 }}
      - alias: If the target brightness is unspecified
        condition: template
        value_template: |
          {{ brightness is none }}
      - alias: If the target brightness is below a power on minimum %
        condition: template
        value_template: |
          {% set global = namespace(result=false) %}
          {% for entity_id in target_entity_ids %}
            {% if not global.result %}
              {% set global.result = 0 < brightness < light_config[entity_id].on_minimum %}
            {% endif %}
          {% endfor %}
          {{ global.result }}

actions:
  - alias: If triggered by call service and target brightness is unspecified
    if:
      - condition: trigger
        id:
          - call_service
      - condition: template
        value_template: "{{ brightness is none }}"
    then:
      - alias: Wait for the target entity states to update
        wait_template: |
          {{ expand(target_entity_ids) | map(attribute='last_changed') | sort | first > as_datetime(trigger_time) }}
        continue_on_timeout: true
        timeout: "00:00:01"

  - alias: Determine lights with target brightness below on minimum %
    variables:
      target_brightness: |
        {# Get target brightness for each light #}
        {% set global = namespace(brightness={}) %}
        {% for entity_id in target_entity_ids %}
          {% set target_brightness = brightness if brightness else state_attr(entity_id, 'brightness')|int(none) %}
          {% set global.brightness = dict(global.brightness, **{entity_id: target_brightness}) %}
        {% endfor %}
        {{ global.brightness }}
      transition_remaining: |
        {{ (as_datetime(trigger_time) + timedelta(seconds=transition) - now()).total_seconds() }}
      transition_pct: |
        {{ min(1 - transition_remaining / transition, 1) if transition > 0 else 1 }}
      scene_on_minimum: |
        {% set global = namespace(scene_entities={}) %}
        {% for entity_id, target_brightness in target_brightness.items() %}
          {% set cooldown = light_config[entity_id].cooldown %}
          {% set on_minimum = light_config[entity_id].on_minimum %}

          {# Warm lights get a lower power on minimum #}
          {% set fraction = min(matched_off_duration[entity_id] / (cooldown or 1), 1) %}
          {% set adjusted_minimum = max(on_minimum * fraction, 1) | round %}

          {# Add lights with brightness below the adjusted minimum to the scene #}
          {% if target_brightness and target_brightness * transition_pct < adjusted_minimum %}
            {% set global.scene_entities = dict(global.scene_entities, **{
              entity_id: { 'state': 'on','brightness': adjusted_minimum}
            }) %}
          {% endif %}
        {% endfor %}
        {{ global.scene_entities }}

  - alias: Apply the power on minimum brightness for each light
    if:
      - condition: template
        value_template: "{{ not not scene_on_minimum }}"
    then:
      - action: scene.apply
        data:
          entities: "{{ scene_on_minimum }}"
          transition: 0
      - alias: Wait during light warm-up
        delay:
          milliseconds: 500
    else:
      - stop: All lights are above their power on minimum brightness

  - alias: Apply interim brightness to resume long transitions
    variables:
      transition_remaining: |
        {{ (as_datetime(trigger_time) + timedelta(seconds=transition) - now()).total_seconds() }}
      transition_pct: |
        {{ min(1 - transition_remaining / transition, 1) if transition > 0 else 1 }}
      scene_interim: |
        {% set global = namespace(scene_entities={}) %}
        {% for entity_id, minimum in scene_on_minimum.items() %}
          {# Determine interim brightness from remaining transition #}
          {% set interim_brightness = max(target_brightness[entity_id] * transition_pct, 1) | round %}
          {% if minimum.brightness != interim_brightness != target_brightness[entity_id] %}
            {% set global.scene_entities = dict(global.scene_entities, **{
              entity_id: { 'state': 'on','brightness': interim_brightness}
            }) %}
          {% endif %}
        {% endfor %}
        {{ global.scene_entities }}
  - if:
      - condition: template
        value_template: "{{ not not scene_interim }}"
    then:
      - action: scene.apply
        data:
          entities: "{{ scene_interim }}"
          transition: 0

  - alias: Apply the final brightness with remaining transition
    variables:
      transition_remaining: |
        {{ (as_datetime(trigger_time) + timedelta(seconds=transition) - now()).total_seconds() }}
      scene_final: |
        {% set global = namespace(scene_entities={}) %}
        {% for entity_id, minimum in scene_on_minimum.items() %}
          {% if target_brightness[entity_id] != minimum.brightness %}
            {% set global.scene_entities = dict(global.scene_entities, **{
              entity_id: {'state': 'on', 'brightness': target_brightness[entity_id]}
            }) %}
          {% endif %}
        {% endfor %}
        {{ global.scene_entities }}
  - if:
      - condition: template
        value_template: "{{ not not scene_final }}"
    then:
      - action: scene.apply
        data:
          entities: "{{ scene_final }}"
          transition: "{{ max(transition_remaining | round, 0) }}"

  - alias: Apply Adaptive Lighting if target brightness was unspecified
    if:
      - condition: template
        value_template: "{{ brightness is none and not not integration_entities('adaptive_lighting') }}"
    then:
      - alias: Wait for the remaining transition to complete
        delay:
          seconds: |
            {{ max((as_datetime(trigger_time) + timedelta(seconds=transition) - now()).total_seconds(), 0) }}
      - action: adaptive_lighting.apply
        continue_on_error: true
        data:
          lights: "{{ scene_on_minimum.keys() | list }}"

mode: parallel
max: 20
trace:
  stored_traces: 10
