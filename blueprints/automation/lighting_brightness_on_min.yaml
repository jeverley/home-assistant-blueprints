blueprint:
  name: Dimmer Power on Minimum
  description: "Automatically set lights to a minimum brightness when turning on, with configurable minimums per light entity"
  domain: automation
  source_url: https://raw.githubusercontent.com/jeverley/home-assistant-blueprints/refs/heads/main/blueprints/automation/lighting_brightness_on_min.yaml
  input:
    light_config:
      name: Lights configuration
      description: "Configure minimum brightness percentage and cooldown duration for each light"
      selector:
        object:
          label_field: entity_id
          multiple: true
          fields:
            entity_id:
              label: Light
              selector:
                entity:
                  multiple: false
                  filter:
                    - domain:
                        - light
            min_pct:
              label: Power on minimum brightness
              selector:
                number:
                  min: 1
                  max: 100
                  unit_of_measurement: "%"
            cooldown:
              label: Cooldown duration
              selector:
                number:
                  min: 0
                  max: 60
                  step: 1
                  unit_of_measurement: s
      default: []
    default_transition:
      name: Default transition
      description: "Default transition time when not specified in the trigger event"
      default: 0
      selector:
        number:
          min: 0
          max: 10
          step: 1
          unit_of_measurement: s
    advanced_settings:
      name: Advanced Settings
      icon: mdi:cog
      description: Advanced configuration
      collapsed: true
      input:
        state_trigger:
          name: Apply when a light is physically turned on
          default: false
          selector:
            boolean:
        state_hold_duration:
          name: State hold duration
          description: Time to wait for state updates to complete when a light is physically turned on
          default: 0.5
          selector:
            number:
              min: 0
              max: 2
              step: 0.1
              unit_of_measurement: s

trigger_variables:
  scale_factor: 2.55
  default_transition: !input default_transition
  light_config_objects: !input light_config
  light_config: |
    {% set global = namespace(config={}) %}
    {% for config in light_config_objects %}
      {% set global.config = dict(global.config, **{
        config.entity_id: {
          'on_minimum': (config.min_pct|default(0) * scale_factor) | round,
          'cooldown': config.cooldown|default(0)
        }
      }) %}
    {% endfor %}
    {{ global.config }}
  state_hold_duration: !input state_hold_duration
  is_al_installed: |
    {{ not not integration_entities('adaptive_lighting') }}

triggers:
  - alias: When the light turn_on service is called
    id: turn_on
    trigger: event
    event_type: call_service
    event_data:
      domain: light
      service: turn_on
    enabled: true
  - alias: When the light toggle service is called
    id: toggle
    trigger: event
    event_type: call_service
    event_data:
      domain: light
      service: toggle
    enabled: true
  - alias: When a light state changes from off to on (filtered in conditions)
    id: state_changed
    trigger: event
    event_type: state_changed
    event_data: {}
    enabled: !input state_trigger

variables:
  trigger_time: |
    {% if trigger.event is defined %}
      {{ trigger.event.time_fired }}
    {% else %}
      {{ now() }}
    {% endif %}
  trigger_event_type: |
    {{ trigger.event.event_type if trigger.event is defined else none }}
  trigger_entity_ids: |
    {% if trigger_event_type == 'call_service' %}
      {# Resolve entity_ids from event targets #}
      {% set sd = trigger.event.data.service_data %}
      {% set entity_ids = [] if sd.entity_id is not defined else [sd.entity_id] if sd.entity_id is string else sd.entity_id %}
      {% set device_ids = [] if sd.device_ids is not defined else [sd.device_ids] if sd.device_ids is string else sd.device_ids %}
      {% set area_ids = [] if sd.area_ids is not defined else [sd.area_ids] if sd.area_ids is string else sd.area_ids %}
      {% set floor_ids = [] if sd.floor_ids is not defined else [sd.floor_ids] if sd.floor_ids is string else sd.floor_ids %}
      {% set label_ids = [] if sd.label_ids is not defined else [sd.label_ids] if sd.label_ids is string else sd.label_ids %}
      {% set resolved_entities =
        (
          (area_ids | map('area_entities')|flatten if area_ids else [])
          + (floor_ids | map('floor_entities')|flatten if floor_ids else [])
          + (label_ids | map('label_entities')|flatten if label_ids else [])
          + (label_ids | map('label_devices')|flatten | map('device_entities')|flatten if label_ids else [])
        ) | select('contains', 'light.') | list
      %}
      {{ (resolved_entities + entity_ids) | unique | list }}
    {% elif
      trigger_event_type == 'state_changed'
      and trigger.event.data.new_state
      and trigger.event.data.old_state
      and 'light.' in trigger.event.data.new_state.entity_id
      and trigger.event.data.old_state.state == 'off'
      and trigger.event.data.new_state.state == 'on'
      and trigger.event.data.new_state.attributes.brightness|default(none) is not none
    %}
      {{ [trigger.event.data.new_state.entity_id] }}
    {% else %}
      {{ [] }}
    {% endif %}

  matched_entity_ids: |
    {{ intersect(trigger_entity_ids, light_config) }}
  matched_off_duration: |
    {# Get the duration in seconds that each matched light was off #}
    {% set global = namespace(off_duration={}) %}
    {% if trigger_event_type == 'call_service' %}
      {# Determine off durations from matched entity states #}
      {% for state in expand(matched_entity_ids) %}
        {% if state.state == 'off' and state.last_changed < as_datetime(trigger_time) %}
          {% set global.off_duration = dict(global.off_duration, **{
            state.entity_id: (as_datetime(trigger_time) - state.last_changed).total_seconds()
          }) %}
        {% elif state.state == 'on' and state.last_changed > as_datetime(trigger_time) %}
          {% set global.off_duration = dict(global.off_duration, **{
            state.entity_id: none
          }) %}
        {% endif %}
      {% endfor %}
    {% elif trigger_event_type == 'state_changed' and matched_entity_ids %}
      {# Determine off duration from the prevous state #}
      {% set global.off_duration = {
        trigger.event.data.new_state.entity_id: (as_datetime(trigger_time) - trigger.event.data.old_state.last_changed).total_seconds()
      } %}
    {% endif %}
    {{ global.off_duration }}
  target_entity_ids: |
    {{ matched_off_duration.keys() | list }}

  brightness: |
    {% if trigger.event is not defined %}
      {{ none }}
    {% elif trigger_event_type == 'state_changed' %}
      {{
        trigger.event.data.new_state.attributes.brightness|default(none)|int(none)
        if trigger.event.data.new_state else none
      }}
    {% elif trigger.event.data.service_data.brightness is defined %}
      {{ trigger.event.data.service_data.brightness|int(none) }}
    {% elif trigger.event.data.service_data.brightness_pct|default(none) is number %}
      {{ (trigger.event.data.service_data.brightness_pct * scale_factor) | round }}
    {% else %}
      {{ none }}
    {% endif %}
  brightness_deferred: |
    {{ not brightness or trigger_event_type == 'state_changed' and state_hold_duration > 0 }}
  transition: |
    {{
      trigger.event.data.service_data.transition|default(default_transition)|int(0)
      if trigger_event_type == 'call_service'
      else 0
    }}

conditions:
  - alias: If the trigger has valid target lights that were off
    condition: template
    value_template: "{{ not not target_entity_ids }}"
  - alias: If the trigger instigated the change
    condition: template
    value_template: |
      {{
        trigger_event_type == 'call_service'
        or trigger.event.context.user_id is none
        and trigger.event.context.parent_id is none
        and trigger.event.context.id is not search(':al:.*:.*:')
      }}
  - condition: or
    conditions:
      - alias: If transition is long enough to perceive a delay
        condition: template
        value_template: |
          {{ transition > 1 }}
      - alias: If the target brightness is unspecified
        condition: template
        value_template: |
          {{ brightness is none }}
      - alias: If the target brightness is below a power on minimum %
        condition: template
        value_template: |
          {% set global = namespace(result=false) %}
          {% for entity_id in target_entity_ids %}
            {% if not global.result %}
              {% set global.result = 0 < brightness < light_config[entity_id].on_minimum %}
            {% endif %}
          {% endfor %}
          {{ global.result }}

actions:
  - alias: Handle wait for deferred brightness evaluation
    choose:
      - alias: Wait for state updates if target brightness was unspecified in the service call
        conditions:
          - condition: template
            value_template: "{{ trigger_event_type == 'call_service' and brightness_deferred }}"
        sequence:
          - wait_template: |
              {{ expand(target_entity_ids) | map(attribute='last_changed') | sort | first > as_datetime(trigger_time) }}
            continue_on_timeout: true
            timeout: "00:00:01"

      - alias: Wait for subsequent state updates to complete
        conditions:
          - condition: template
            value_template: "{{ trigger_event_type == 'state_changed' and brightness_deferred }}"
        sequence:
          - repeat:
              sequence:
                - delay: "{{ states[trigger.event.data.new_state.entity_id].last_updated + timedelta(seconds=state_hold_duration) - now() }}"
              until:
                - condition: template
                  value_template: |
                    {% set state = states[trigger.event.data.new_state.entity_id] %}
                    {{ state.state != 'on' or state.last_updated <= now() - timedelta(seconds=state_hold_duration) }}

  - alias: Determine lights with target brightness below on minimum %
    variables:
      target_brightness: |
        {# Get target brightness for each light #}
        {% set global = namespace(brightness={}) %}
        {% for entity_id in target_entity_ids %}
          {% set target_brightness =
            brightness if not brightness_deferred
            else state_attr(entity_id, 'brightness')|int(none)
          %}
          {% set global.brightness = dict(global.brightness, **{entity_id: target_brightness}) %}
        {% endfor %}
        {{ global.brightness }}
      transition_remaining: |
        {{ (as_datetime(trigger_time) + timedelta(seconds=transition) - now()).total_seconds() }}
      transition_pct: |
        {{ min(1 - transition_remaining / transition, 1) if transition > 0 else 1 }}
      scene_on_minimum: |
        {% set global = namespace(scene_entities={}) %}
        {% for entity_id, target_brightness in target_brightness.items() %}
          {% set cooldown = light_config[entity_id].cooldown %}
          {% set on_minimum = light_config[entity_id].on_minimum %}

          {# Warm lights get a lower power on minimum #}
          {% set fraction = min(matched_off_duration[entity_id]|default(cooldown) / cooldown, 1) if cooldown else 1 %}
          {% set adjusted_minimum = max(on_minimum * fraction, 1) | round %}

          {# Add lights with brightness below the adjusted minimum to the scene #}
          {% if target_brightness and target_brightness * transition_pct < adjusted_minimum %}
            {% set global.scene_entities = dict(global.scene_entities, **{
              entity_id: { 'state': 'on','brightness': adjusted_minimum}
            }) %}
          {% endif %}
        {% endfor %}
        {{ global.scene_entities }}

  - alias: Apply the power on minimum brightness for each light
    if:
      - condition: template
        value_template: "{{ not not scene_on_minimum }}"
    then:
      - action: scene.apply
        data:
          entities: "{{ scene_on_minimum }}"
          transition: 0
      - alias: Wait during light warm-up
        delay:
          milliseconds: 500
    else:
      - stop: All lights are above their power on minimum brightness

  - alias: Apply interim brightness to resume long transitions
    variables:
      transition_remaining: |
        {{ (as_datetime(trigger_time) + timedelta(seconds=transition) - now()).total_seconds() }}
      transition_pct: |
        {{ min(1 - transition_remaining / transition, 1) if transition > 0 else 1 }}
      scene_interim: |
        {% set global = namespace(scene_entities={}) %}
        {% for entity_id, minimum in scene_on_minimum.items() %}
          {# Determine interim brightness from remaining transition #}
          {% set interim_brightness = max(target_brightness[entity_id] * transition_pct, 1) | round %}
          {% if minimum.brightness != interim_brightness != target_brightness[entity_id] %}
            {% set global.scene_entities = dict(global.scene_entities, **{
              entity_id: { 'state': 'on','brightness': interim_brightness}
            }) %}
          {% endif %}
        {% endfor %}
        {{ global.scene_entities }}
  - if:
      - condition: template
        value_template: "{{ not not scene_interim }}"
    then:
      - action: scene.apply
        data:
          entities: "{{ scene_interim }}"
          transition: 0

  - alias: Apply the final brightness with remaining transition
    variables:
      transition_remaining: |
        {{ (as_datetime(trigger_time) + timedelta(seconds=transition) - now()).total_seconds() }}
      scene_final: |
        {% set global = namespace(scene_entities={}) %}
        {% for entity_id, minimum in scene_on_minimum.items() %}
          {% if target_brightness[entity_id] != minimum.brightness %}
            {% set global.scene_entities = dict(global.scene_entities, **{
              entity_id: {'state': 'on', 'brightness': target_brightness[entity_id]}
            }) %}
          {% endif %}
        {% endfor %}
        {{ global.scene_entities }}
  - if:
      - condition: template
        value_template: "{{ not not scene_final }}"
    then:
      - action: scene.apply
        data:
          entities: "{{ scene_final }}"
          transition: "{{ max(transition_remaining | round, 0) }}"

  - alias: Apply Adaptive Lighting if target brightness was unspecified
    if:
      - condition: template
        value_template: "{{ is_al_installed and brightness is none }}"
    then:
      - alias: Wait for the remaining transition to complete
        delay:
          seconds: |
            {{ max((as_datetime(trigger_time) + timedelta(seconds=transition) - now()).total_seconds(), 0) }}
      - action: adaptive_lighting.apply
        continue_on_error: true
        data:
          lights: "{{ scene_on_minimum.keys() | list }}"

mode: parallel
max: 50
trace:
  stored_traces: 0
