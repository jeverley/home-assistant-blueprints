blueprint:
  name: Lights Start-up Minimum Brightness
  description: "Ensures lights turn on at a brightness level high enough to reliably activate bulbs with minimum voltage thresholds, then restores the originally requested brightness."
  domain: automation
  source_url: https://raw.githubusercontent.com/jeverley/home-assistant-blueprints/refs/heads/main/blueprints/automation/lights_startup_minimum_brightness.yaml
  input:
    light_config:
      name: Lights configuration
      description: Configure minimum brightness percentage and cooldown duration for each light.
      selector:
        object:
          label_field: entity_id
          multiple: true
          fields:
            entity_id:
              label: Light
              selector:
                entity:
                  multiple: false
                  filter:
                    - domain:
                        - light
            minimum_pct:
              label: Start-up minimum brightness.
              selector:
                number:
                  min: 1
                  max: 100
                  step: 1
                  unit_of_measurement: "%"
            cooldown:
              label: Cooldown duration.
              selector:
                number:
                  min: 0
                  max: 60
                  step: 1
                  unit_of_measurement: s
      default: []
    default_transition:
      name: Default transition
      description: This is used when a transition is not specified in the trigger event. <br /><br />`Optional`
      default: 0
      selector:
        number:
          min: 0
          max: 10
          step: 1
          unit_of_measurement: s
    state_trigger:
      name: Apply after physical turn on
      description: Enable to handle lights with physical switches that can be turned on outside of Home Assistant. <br /><br />`Optional`
      default: false
      selector:
        boolean:
    advanced_settings:
      name: Advanced Settings
      icon: mdi:wrench-cog
      collapsed: true
      input:
        state_debounce_duration:
          name: Physical state debounce duration
          description: "
            Duration to wait for subsequent state updates before evaluating target brightness,\n
            this allows other automations to complete.
            <br /><br />`Optional`"
          default: 0.5
          selector:
            number:
              min: 0
              max: 2
              step: 0.1
              unit_of_measurement: s
        stored_traces:
          name: Stored traces
          description: "
            <strong>WARNING:</strong> Non-zero values result in poor performance when used with the setting:\n
            _'Apply after physical turn on'_.
            <br /><br />`Optional`"
          default: 0
          selector:
            number:
              min: 0
              max: 20
              step: 1

trigger_variables:
  scale_factor: 2.55
  warmup_ms: 500
  interval_ms: 10
  default_transition: !input default_transition
  state_debounce_duration: !input state_debounce_duration
  light_config_objects: !input light_config
  light_config: |
    {% set global = namespace(config={}) %}
    {% for config in light_config_objects %}
      {% set global.config = dict(global.config, **{
        config.entity_id: {
          'minimum': (config.minimum_pct|default(0) * scale_factor) | round,
          'cooldown': config.cooldown|default(0)
        }
      }) %}
    {% endfor %}
    {{ global.config }}
  is_al_installed: "{{ not not integration_entities('adaptive_lighting') }}"

triggers:
  - alias: When the light turn_on service is called
    id: turn_on
    trigger: event
    event_type: call_service
    event_data:
      domain: light
      service: turn_on
    enabled: true
  - alias: When the light toggle service is called
    id: toggle
    trigger: event
    event_type: call_service
    event_data:
      domain: light
      service: toggle
    enabled: true
  - alias: When a light state changes from off to on (filtered in conditions)
    id: state_changed
    trigger: event
    event_type: state_changed
    event_data: {}
    enabled: !input state_trigger

variables:
  trigger_time: |
    {{ trigger.event.time_fired if trigger.event is defined else now() }}
  trigger_event_type: |
    {{ trigger.event.event_type if trigger.event is defined else none }}
  trigger_entity_ids: |
    {% if trigger_event_type == 'call_service' %}
      {# Resolve entity_ids from event targets #}
      {% set sd = trigger.event.data.service_data %}
      {% set entity_ids = [] if sd.entity_id is not defined else [sd.entity_id] if sd.entity_id is string else sd.entity_id %}
      {% set device_ids = [] if sd.device_ids is not defined else [sd.device_ids] if sd.device_ids is string else sd.device_ids %}
      {% set area_ids = [] if sd.area_ids is not defined else [sd.area_ids] if sd.area_ids is string else sd.area_ids %}
      {% set floor_ids = [] if sd.floor_ids is not defined else [sd.floor_ids] if sd.floor_ids is string else sd.floor_ids %}
      {% set label_ids = [] if sd.label_ids is not defined else [sd.label_ids] if sd.label_ids is string else sd.label_ids %}
      {% set resolved_entities = (
        (device_ids | map('device_entities')|flatten if device_ids else [])
        + (area_ids | map('area_entities')|flatten if area_ids else [])
        + (floor_ids | map('floor_entities')|flatten if floor_ids else [])
        + (label_ids | map('label_entities')|flatten if label_ids else [])
        + (label_ids | map('label_devices')|flatten | map('device_entities')|flatten if label_ids else [])
      ) %}
      {{ intersect(resolved_entities + entity_ids, light_config) }}
    {% elif trigger_event_type == 'state_changed' %}
      {# Only include lights changing from off to on with brightness #}
      {% set ed = trigger.event.data %}
      {{
        [ed.new_state.entity_id]
        if ed.new_state
        and ed.new_state.entity_id in light_config
        and ed.old_state
        and ed.old_state.state == 'off'
        and ed.new_state.state == 'on'
        and ed.new_state.attributes.brightness|default(none) is number
        else []
      }}
    {% else %}
      {{ [] }}
    {% endif %}

  off_duration: |
    {# Get the duration in seconds that each matched light was off #}
    {% set global = namespace(off_duration={}) %}
    {% set trigger_time = as_datetime(trigger_time) %}
    {% if trigger_event_type == 'call_service' %}
      {# Determine off durations from trigger entity states #}
      {% for state in expand(trigger_entity_ids) %}
        {% if state.state == 'off' and state.last_changed < trigger_time %}
          {% set global.off_duration = dict(global.off_duration, **{
            state.entity_id: (trigger_time - state.last_changed).total_seconds()
          }) %}
        {% elif state.state == 'on' and state.last_changed > trigger_time %}
          {% set global.off_duration = dict(global.off_duration, **{
            state.entity_id: none
          }) %}
        {% endif %}
      {% endfor %}
    {% elif trigger_event_type == 'state_changed' and trigger_entity_ids %}
      {# Determine off duration from the old state #}
      {% set global.off_duration = {
        trigger.event.data.new_state.entity_id: (trigger_time - trigger.event.data.old_state.last_changed).total_seconds()
      } %}
    {% endif %}
    {{ global.off_duration }}
  target_entity_ids: |
    {{ off_duration.keys() | list }}
  brightness: |
    {% if trigger_event_type == 'call_service' %}
      {% set sd = trigger.event.data.service_data %}
      {{
        sd.brightness if sd.brightness|default(none) is number
        else (sd.brightness_pct * scale_factor) | round if sd.brightness_pct|default(none) is number
        else none
      }}
    {% elif trigger_event_type == 'state_changed' and trigger_entity_ids %}
      {{ trigger.event.data.new_state.attributes.brightness }}
    {% else %}
      {{ none }}
    {% endif %}
  transition: |
    {{
      trigger.event.data.service_data.transition|default(default_transition)|int(0)
      if trigger_event_type == 'call_service'
      else 0
    }}

conditions:
  - alias: If the trigger has valid target lights that were off
    condition: template
    value_template: "{{ not not target_entity_ids }}"
  - alias: If the trigger instigated the change
    condition: template
    value_template: |
      {{
        trigger_event_type == 'call_service'
        or trigger.event.context.user_id is none
        and trigger.event.context.parent_id is none
        and trigger.event.context.id is not search(':al:.*:.*:')
      }}
  - condition: or
    conditions:
      - alias: If transition is long enough to perceive a delay
        condition: template
        value_template: |
          {{ transition > 0 }}
      - alias: If the target brightness is unspecified
        condition: template
        value_template: |
          {{ brightness is none }}
      - alias: If the target brightness is below a start-up minimum %
        condition: template
        value_template: |
          {% set global = namespace(result=false) %}
          {% for entity_id in target_entity_ids %}
            {% if not global.result %}
              {% set global.result = 0 < brightness < light_config[entity_id].minimum %}
            {% endif %}
          {% endfor %}
          {{ global.result }}

actions:
  - alias: Post trigger variables
    variables:
      transition_end: |
        {{ as_datetime(trigger_time) + timedelta(seconds=transition) }}
      brightness_deferred: |
        {{ not brightness or trigger_event_type == 'state_changed' and state_debounce_duration > 0 }}

  - alias: Wait for deferred brightness evaluation
    choose:
      - alias: Wait for target states to change if brightness was unspecified in the service call
        conditions:
          - condition: template
            value_template: "{{ trigger_event_type == 'call_service' and brightness_deferred }}"
        sequence:
          - wait_template: |
              {{ expand(target_entity_ids) | map(attribute='last_changed') | sort | first > as_datetime(trigger_time) }}
            continue_on_timeout: true
            timeout: "{{ max(as_datetime(trigger_time) + timedelta(seconds=1) - now(), timedelta(0)) }}"

      - alias: Wait for subsequent state updates to complete (state debounce)
        conditions:
          - condition: template
            value_template: "{{ trigger_event_type == 'state_changed' and brightness_deferred }}"
        sequence:
          - repeat:
              sequence:
                - delay: |
                    {{ max(states[target_entity_ids[0]].last_updated + timedelta(seconds=state_debounce_duration) - now(), timedelta(0)) }}
              until:
                - condition: template
                  value_template: |
                    {% set state = states[target_entity_ids[0]] %}
                    {{ state.state != 'on' or state.last_updated <= now() - timedelta(seconds=state_debounce_duration) }}

  - alias: Determine lights with target brightness below on minimum %
    variables:
      target_brightness: |
        {# Get target brightness for each light #}
        {% set global = namespace(brightness={}) %}
        {% for entity_id in target_entity_ids %}
          {% set global.brightness = dict(global.brightness, **{
            entity_id: brightness if not brightness_deferred else state_attr(entity_id, 'brightness')|int(none)
          }) %}
        {% endfor %}
        {{ global.brightness }}
      scene_minimum: |
        {% set warmup = namespace(s={}) %}
        {% set instant = namespace(s={}) %}
        {% set transition_remaining = (as_datetime(transition_end) - now()).total_seconds() %}
        {% set transition_pct = min(1 - transition_remaining / transition, 1) if transition else 1 %}

        {% for entity_id, target_brightness in target_brightness.items() %}
          {# Warm lights get a reduced start-up minimum #}
          {% set cooldown = light_config[entity_id].cooldown %}
          {% set off_duration = off_duration[entity_id] %}
          {% set cool_pct = min(off_duration / cooldown, 1) if cooldown and off_duration is not none else 1 %}
          {% set adjusted_minimum = max(light_config[entity_id].minimum * cool_pct, 1) | round %}
          
          {# Add lights with brightness below the adjusted minimum to the scene #}
          {% if not target_brightness or target_brightness * transition_pct >= adjusted_minimum %}
            {# Brightness above minimum #}
          {% elif transition_remaining > 1 or adjusted_minimum > target_brightness %}
            {# Apply minimum brightness for the warmup duration #}
            {% set warmup.s = dict(warmup.s, **{
              entity_id: { 'state': 'on', 'brightness': adjusted_minimum}
            }) %}
          {% else %}
            {# Apply minimum brightness and continue transition #}
            {% set instant.s = dict(instant.s, **{
              entity_id: { 'state': 'on', 'brightness': adjusted_minimum}
            }) %}
          {% endif %}
        {% endfor %}
        {{ {'warmup': warmup.s, 'instant': instant.s} }}

  - alias: Apply the start-up minimum for target lights
    if:
      - condition: template
        value_template: "{{ not not scene_minimum.instant or not not scene_minimum.warmup }}"
    then:
      - alias: Apply the start-up minimum brightness for each light
        action: scene.apply
        data:
          entities: "{{ combine(scene_minimum.instant, scene_minimum.warmup) }}"
          transition: 0
    else:
      - stop: All lights are above their start-up minimum brightness

  - parallel:
      - alias: Apply the final brightness with remaining transition for instant lights
        if:
          - condition: template
            value_template: "{{ not not scene_minimum.instant }}"
        then:
          - delay:
              milliseconds: "{{ interval_ms }}"
          - action: scene.apply
            data:
              entities: |
                {% set global = namespace(scene={}) %}
                {% for entity_id in scene_minimum.instant.keys() %}
                  {% set global.scene = dict(global.scene, **{
                    entity_id: {'state': 'on', 'brightness': target_brightness[entity_id]}
                  }) %}
                {% endfor %}
                {{ global.scene }}
              transition: "{{ max((as_datetime(transition_end) - now()).total_seconds(), 0) }}"

      - alias: Wait the warmup duration, then apply interim and final brightness
        if:
          - condition: template
            value_template: "{{ not not scene_minimum.warmup }}"
        then:
          - delay:
              milliseconds: "{{ warmup_ms }}"
          - alias: Apply interim brightness to resume long transitions
            action: scene.apply
            data:
              entities: |
                {% set global = namespace(scene={}) %}
                {% set transition_remaining = (as_datetime(transition_end) - now()).total_seconds() %}
                {% set transition_pct = min(1 - transition_remaining / transition, 1) if transition else 1 %}

                {% for entity_id, minimum in scene_minimum.warmup.items() %}
                  {# Determine interim brightness from remaining transition #}
                  {% set interim_brightness = max(target_brightness[entity_id] * transition_pct, 1) | round %}
                  {% if minimum.brightness != interim_brightness != target_brightness[entity_id] %}
                    {% set global.scene = dict(global.scene, **{
                      entity_id: {'state': 'on','brightness': interim_brightness}
                    }) %}
                  {% endif %}
                {% endfor %}
                {{ global.scene }}
              transition: 0
          - delay:
              milliseconds: "{{ interval_ms }}"
          - alias: Apply the final brightness with remaining transition
            action: scene.apply
            data:
              entities: |
                {% set global = namespace(scene={}) %}
                {% for entity_id in scene_minimum.warmup.keys() %}
                  {% set global.scene = dict(global.scene, **{
                    entity_id: {'state': 'on', 'brightness': target_brightness[entity_id]}
                  }) %}
                {% endfor %}
                {{ global.scene }}
              transition: "{{ max((as_datetime(transition_end) - now()).total_seconds(), 0) }}"

  - alias: Re-apply Adaptive Lighting if target brightness was unspecified
    if:
      - condition: template
        value_template: "{{ is_al_installed and brightness is none or trigger_event_type == 'state_changed' }}"
    then:
      - alias: Wait for the remaining transition to complete
        delay: |
          {{ max(as_datetime(transition_end) - now(), timedelta(0)) }}
      - action: adaptive_lighting.apply
        continue_on_error: true
        data:
          lights: "{{ union(scene_minimum.instant, scene_minimum.warmup) }}"

mode: parallel
max: 50
trace:
  stored_traces: !input stored_traces
